\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage[spanish]{babel}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{amsmath}
\usepackage{geometry}
\usepackage{tikz}
\usepackage{forest}
\usepackage{booktabs}
\geometry{margin=1in}

\title{Pseudocódigo: Códigos de Huffman con Fuerza Bruta}
\author{Algoritmo de Fuerza Bruta}
\date{\today}

\begin{document}

\maketitle

\section{Descripción del Problema}
%<*enunciado>
El problema de codificación de Huffman consiste en encontrar el código de longitud variable óptimo para un conjunto de símbolos dados sus frecuencias de aparición. El objetivo es minimizar la longitud promedio de codificación, que se calcula como:

$$\text{Costo} = \sum_{i=1}^{n} f_i \cdot l_i$$

donde $f_i$ es la frecuencia del símbolo $i$ y $l_i$ es la longitud del código asignado al símbolo $i$.

El algoritmo de fuerza bruta resuelve este problema generando todos los posibles árboles binarios completos con $n$ hojas y evaluando todas las asignaciones posibles de símbolos a longitudes de código.
%</enunciado>

\section{Pseudocódigo}

\begin{algorithm}
\caption{Generación de Árboles Binarios Completos}
\begin{algorithmic}[1]
%<*codigo1a>
\Require Número de hojas $n$
\Ensure Lista de todos los árboles binarios completos con $n$ hojas

\If{$n = 1$}
    \Return $[x]$ \Comment{Árbol con una sola hoja}
\EndIf

\State $trees \leftarrow$ lista vacía
\For{$left\_size = 1$ to $n-1$}
    \State $right\_size \leftarrow n - left\_size$
    \For{cada $left$ en $generate\_trees(left\_size)$}
        \For{cada $right$ en $generate\_trees(right\_size)$}
            \State $trees.append((left, right))$
        \EndFor
    \EndFor
\EndFor
\Return $trees$
%</codigo1a>
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{Cálculo de Longitudes de Código}
\begin{algorithmic}[1]
%<*codigo1b>
\Require Árbol binario $tree$ y profundidad inicial $depth$
\Ensure Lista de longitudes de código para cada hoja

\If{$tree = x$}
    \Return $[depth]$ \Comment{Hoja del árbol}
\EndIf

\State $left, right \leftarrow tree$
\State $left\_lengths \leftarrow code\_lengths(left, depth+1)$
\State $right\_lengths \leftarrow code\_lengths(right, depth+1)$
\Return $left\_lengths + right\_lengths$
%</codigo1b>
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{Códigos de Huffman con Fuerza Bruta}
\begin{algorithmic}[1]
%<*codigo1c>
\Require Lista de símbolos $symbols$ y frecuencias $freqs$
\Ensure Costo mínimo y asignación óptima de longitudes de código

\State $n \leftarrow$ longitud de $symbols$
\State $best\_cost \leftarrow \infty$
\State $best\_assignment \leftarrow$ \textbf{null}

\For{cada $tree$ en $generate\_trees(n)$}
    \State $lengths \leftarrow code\_lengths(tree)$
    \For{cada $perm$ en $permutations(range(n))$}
        \State $cost \leftarrow \sum_{i=0}^{n-1} freqs[perm[i]] \cdot lengths[i]$
        \If{$cost < best\_cost$}
            \State $best\_cost \leftarrow cost$
            \State $best\_assignment \leftarrow \{symbols[perm[i]]: lengths[i] \text{ para } i = 0 \text{ a } n-1\}$
        \EndIf
    \EndFor
\EndFor
\Return $best\_cost, best\_assignment$
%</codigo1c>
\end{algorithmic}
\end{algorithm}

\section{Explicación del Algoritmo}

\subsection{Enfoque de Fuerza Bruta}
%<*exp1>
El algoritmo de fuerza bruta para códigos de Huffman funciona de la siguiente manera:

\begin{itemize}
    \item \textbf{Generación de árboles:} Se generan todos los posibles árboles binarios completos con $n$ hojas
    \item \textbf{Cálculo de longitudes:} Para cada árbol, se calculan las longitudes de código de todas las hojas
    \item \textbf{Permutaciones de asignación:} Se prueban todas las posibles asignaciones de símbolos a longitudes
    \item \textbf{Evaluación de costo:} Se calcula el costo total para cada asignación
    \item \textbf{Optimización:} Se mantiene la mejor asignación encontrada
\end{itemize}

La complejidad viene del hecho de que se generan todos los árboles binarios posibles y se prueban todas las permutaciones de asignación.
%</exp1>

\subsection{Estructura de Árboles Binarios Completos}
%<*exp2>
Un árbol binario completo con $n$ hojas tiene exactamente $n-1$ nodos internos. Para $n$ símbolos, el número de árboles binarios completos diferentes es el $(n-1)$-ésimo número de Catalan:

$$C_{n-1} = \frac{1}{n}\binom{2(n-1)}{n-1}$$

Para cada árbol, las longitudes de código están determinadas por las profundidades de las hojas, y cada símbolo puede asignarse a cualquier hoja del árbol.
%</exp2>

\subsection{Complejidad}
%<*exp3>
\begin{itemize}
    \item \textbf{Tiempo:} $O(C_{n-1} \cdot n! \cdot n)$
    \begin{itemize}
        \item $O(C_{n-1})$ para generar todos los árboles binarios completos
        \item $O(n!)$ para generar todas las permutaciones de asignación
        \item $O(n)$ para calcular el costo de cada asignación
    \end{itemize}
    \item \textbf{Espacio:} $O(n)$ para almacenar la mejor asignación
\end{itemize}

Esta complejidad exponencial hace que el algoritmo sea impráctico para problemas grandes.
%</exp3>

\section{Resolución Paso a Paso}

\subsection{Ejemplo: Símbolos = ["A","B","C","D"], Frecuencias = [5,2,1,1]}

\textbf{Paso 1:} Identificar parámetros del problema
\begin{itemize}
    \item Número de símbolos: $n = 4$
    \item Número de árboles binarios completos: $C_3 = \frac{1}{4}\binom{6}{3} = 5$
    \item Total de permutaciones por árbol: $4! = 24$
    \item Total de asignaciones a evaluar: $5 \times 24 = 120$
\end{itemize}

\textbf{Paso 2:} Generar todos los árboles binarios completos con 4 hojas

Los 5 árboles binarios completos con 4 hojas son:

\textbf{Árbol 1:} ((x,x), (x,x))
\begin{center}
\begin{tikzpicture}[level distance=1cm, level 1/.style={sibling distance=2cm}, level 2/.style={sibling distance=1cm}]
    \node {root}
        child {
            node {int}
            child {node {A}}
            child {node {B}}
        }
        child {
            node {int}
            child {node {C}}
            child {node {D}}
        };
\end{tikzpicture}
\end{center}
Longitudes: [2, 2, 2, 2]

\textbf{Árbol 2:} (((x,x), x), x)
\begin{center}
\begin{tikzpicture}[level distance=1cm, level 1/.style={sibling distance=2cm}, level 2/.style={sibling distance=1cm}]
    \node {root}
        child {
            node {int}
            child {
                node {int}
                child {node {A}}
                child {node {B}}
            }
            child {node {C}}
        }
        child {node {D}};
\end{tikzpicture}
\end{center}
Longitudes: [3, 3, 2, 1]

\textbf{Árbol 3:} ((x, (x,x)), x)
\begin{center}
\begin{tikzpicture}[level distance=1cm, level 1/.style={sibling distance=2cm}, level 2/.style={sibling distance=1cm}]
    \node {root}
        child {
            node {int}
            child {node {A}}
            child {
                node {int}
                child {node {B}}
                child {node {C}}
            }
        }
        child {node {D}};
\end{tikzpicture}
\end{center}
Longitudes: [2, 3, 3, 1]

\textbf{Árbol 4:} (x, ((x,x), x))
\begin{center}
\begin{tikzpicture}[level distance=1cm, level 1/.style={sibling distance=2cm}, level 2/.style={sibling distance=1cm}]
    \node {root}
        child {node {A}}
        child {
            node {int}
            child {
                node {int}
                child {node {B}}
                child {node {C}}
            }
            child {node {D}}
        };
\end{tikzpicture}
\end{center}
Longitudes: [1, 3, 3, 2]

\textbf{Árbol 5:} (x, (x, (x,x)))
\begin{center}
\begin{tikzpicture}[level distance=1cm, level 1/.style={sibling distance=2cm}, level 2/.style={sibling distance=1cm}]
    \node {root}
        child {node {A}}
        child {
            node {int}
            child {node {B}}
            child {
                node {int}
                child {node {C}}
                child {node {D}}
            }
        };
\end{tikzpicture}
\end{center}
Longitudes: [1, 2, 3, 3]

\textbf{Paso 3:} Evaluar asignaciones para cada árbol

\textbf{Árbol 1:} Longitudes [2, 2, 2, 2]
\begin{itemize}
    \item Todas las asignaciones tienen el mismo costo: $5 \cdot 2 + 2 \cdot 2 + 1 \cdot 2 + 1 \cdot 2 = 18$
    \item \textbf{Costo:} 18
\end{itemize}

\textbf{Árbol 2:} Longitudes [3, 3, 2, 1]
\begin{itemize}
    \item Asignación óptima: A→1, B→2, C→2, D→3
    \item Costo: $5 \cdot 1 + 2 \cdot 2 + 1 \cdot 2 + 1 \cdot 3 = 14$
    \item \textbf{Mejor hasta ahora:} 14
\end{itemize}

\textbf{Árbol 3:} Longitudes [2, 3, 3, 1]
\begin{itemize}
    \item Asignación óptima: A→1, B→2, C→3, D→3
    \item Costo: $5 \cdot 1 + 2 \cdot 2 + 1 \cdot 3 + 1 \cdot 3 = 15$
\end{itemize}

\textbf{Árbol 4:} Longitudes [1, 3, 3, 2]
\begin{itemize}
    \item Asignación óptima: A→1, B→3, C→3, D→2
    \item Costo: $5 \cdot 1 + 2 \cdot 3 + 1 \cdot 3 + 1 \cdot 2 = 16$
\end{itemize}

\textbf{Árbol 5:} Longitudes [1, 2, 3, 3]
\begin{itemize}
    \item Asignación óptima: A→1, B→2, C→3, D→3
    \item Costo: $5 \cdot 1 + 2 \cdot 2 + 1 \cdot 3 + 1 \cdot 3 = 15$
\end{itemize}

\textbf{Paso 4:} Verificar si existe una mejor asignación en el Árbol 2

Evaluando todas las permutaciones del Árbol 2 con longitudes [3, 3, 2, 1]:

\begin{center}
\begin{tabular}{|c|c|c|c|c|}
\hline
\textbf{Permutación} & \textbf{A} & \textbf{B} & \textbf{C} & \textbf{D} \\
\hline
\([0,1,2,3]\) & 3 & 3 & 2 & 1 \\
\([0,1,3,2]\) & 3 & 3 & 1 & 2 \\
\([0,2,1,3]\) & 3 & 2 & 3 & 1 \\
\([0,2,3,1]\) & 3 & 2 & 1 & 3 \\
\([0,3,1,2]\) & 3 & 1 & 3 & 2 \\
\([0,3,2,1]\) & 3 & 1 & 2 & 3 \\
\([1,0,2,3]\) & 3 & 3 & 2 & 1 \\
\([1,0,3,2]\) & 3 & 3 & 1 & 2 \\
\([1,2,0,3]\) & 2 & 3 & 3 & 1 \\
\([1,2,3,0]\) & 2 & 3 & 1 & 3 \\
\([1,3,0,2]\) & 2 & 1 & 3 & 3 \\
\([1,3,2,0]\) & 2 & 1 & 3 & 3 \\
\([2,0,1,3]\) & 3 & 3 & 2 & 1 \\
\([2,0,3,1]\) & 3 & 3 & 1 & 2 \\
\([2,1,0,3]\) & 2 & 3 & 3 & 1 \\
\([2,1,3,0]\) & 2 & 3 & 1 & 3 \\
\([2,3,0,1]\) & 2 & 1 & 3 & 3 \\
\([2,3,1,0]\) & 2 & 1 & 3 & 3 \\
\([3,0,1,2]\) & 3 & 3 & 2 & 1 \\
\([3,0,2,1]\) & 3 & 3 & 1 & 2 \\
\([3,1,0,2]\) & 2 & 3 & 3 & 1 \\
\([3,1,2,0]\) & 2 & 3 & 1 & 3 \\
\([3,2,0,1]\) & 2 & 3 & 3 & 1 \\
\([3,2,1,0]\) & 2 & 3 & 1 & 3 \\
\hline
\end{tabular}
\end{center}

Calculando costos para las asignaciones más prometedoras:
\begin{itemize}
    \item A→1, B→2, C→2, D→3: Costo = $5 \cdot 1 + 2 \cdot 2 + 1 \cdot 2 + 1 \cdot 3 = 14$
    \item A→1, B→2, C→3, D→3: Costo = $5 \cdot 1 + 2 \cdot 2 + 1 \cdot 3 + 1 \cdot 3 = 15$
\end{itemize}

\textbf{Resultado Final:}
\begin{itemize}
    \item \textbf{Mejor costo:} 14
    \item \textbf{Asignación óptima:} \{A: 1, B: 2, C: 2, D: 3\}
    \item \textbf{Árbol óptimo:} Árbol 2 con la asignación específica
\end{itemize}

\subsection{Visualización del Árbol Óptimo}
\begin{center}
\begin{tikzpicture}[level distance=1.5cm, level 1/.style={sibling distance=3cm}, level 2/.style={sibling distance=1.5cm}]
    \node {0}
        child {
            node {0}
            child {
                node {0}
                child {node {A (1)}}
                child {node {B (2)}}
            }
            child {node {C (2)}}
        }
        child {node {D (3)}};
\end{tikzpicture}
\end{center}

\section{Análisis de Complejidad}

\subsection{Comparación con Algoritmo de Huffman Tradicional}
%<*exp4>
\begin{itemize}
    \item \textbf{Fuerza Bruta:} $O(C_{n-1} \cdot n! \cdot n)$ - Garantiza solución óptima
    \item \textbf{Huffman Tradicional:} $O(n \log n)$ - Solución óptima en tiempo polinomial
\end{itemize}

\textbf{Ventajas del enfoque de fuerza bruta:}
\begin{itemize}
    \item Garantiza encontrar la solución óptima
    \item Útil para verificar la corrección del algoritmo de Huffman
    \item Apropiado para problemas pequeños
\end{itemize}

\textbf{Desventajas:}
\begin{itemize}
    \item Complejidad exponencial
    \item Ineficiente para problemas grandes
    \item Redundante cuando existe el algoritmo óptimo de Huffman
\end{itemize}
%</exp4>

\section{Conclusiones}

El algoritmo de fuerza bruta para códigos de Huffman garantiza encontrar la solución óptima pero tiene una complejidad exponencial que lo hace impráctico para problemas grandes. Es útil para:

\begin{itemize}
    \item Verificar la corrección del algoritmo de Huffman tradicional
    \item Resolver instancias pequeñas del problema
    \item Estudios teóricos sobre la optimalidad de soluciones
\end{itemize}

Para aplicaciones prácticas, el algoritmo de Huffman tradicional (con complejidad $O(n \log n)$) es la opción recomendada, ya que produce la misma solución óptima de manera mucho más eficiente.

\end{document}
