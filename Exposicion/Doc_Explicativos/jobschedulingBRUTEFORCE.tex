\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{spanish}
\usepackage{babel}
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{amsmath}
\usepackage{geometry}
\usepackage{booktabs}
\usepackage{array}
\geometry{margin=1in}

\title{Pseudocódigo: Programación de Trabajos con Fuerza Bruta}
\author{Algoritmo de Fuerza Bruta}
\date{\today}

\begin{document}

\maketitle

\section{Descripción del Problema}
%<*enunciado>
El problema de programación de trabajos con deadline (Job Scheduling with Deadlines) consiste en seleccionar y programar un subconjunto de trabajos de manera que se maximice la ganancia total, respetando las restricciones de deadline. Cada trabajo tiene:
\begin{itemize}
    \item Un identificador único
    \item Un deadline (tiempo límite para completar el trabajo)
    \item Una ganancia asociada
\end{itemize}

El objetivo es encontrar la secuencia de trabajos que maximice la ganancia total, donde cada trabajo debe completarse antes de su deadline y cada trabajo toma exactamente una unidad de tiempo.
%</enunciado>

\section{Pseudocódigo}

\begin{algorithm}
\caption{Programación de Trabajos con Fuerza Bruta}
\begin{algorithmic}[1]
%<*codigo1a>
\REQUIRE Una lista $jobs$ de $n$ elementos donde cada elemento es una tupla $(id, deadline, profit)$
\ENSURE La mejor programación y la ganancia máxima

\STATE $max\_profit \leftarrow 0$
\STATE $best\_schedule \leftarrow$ lista vacía

\COMMENT{Probar todas las permutaciones posibles}
\FOR{cada $perm$ en $permutations(jobs)$}
    \STATE $time \leftarrow 0$ \COMMENT{Tiempo actual}
    \STATE $profit \leftarrow 0$ \COMMENT{Ganancia acumulada}
    \STATE $schedule \leftarrow$ lista vacía \COMMENT{Programación actual}
    
    \FOR{cada $job$ en $perm$}
        \IF{$time < job.deadline$}
            \STATE $schedule.append(job)$
            \STATE $profit \leftarrow profit + job.profit$
            \STATE $time \leftarrow time + 1$
        \ENDIF
    \ENDFOR
    
    \IF{$profit > max\_profit$}
        \STATE $max\_profit \leftarrow profit$
        \STATE $best\_schedule \leftarrow schedule$
    \ENDIF
\ENDFOR
\RETURN $best\_schedule, max\_profit$
%</codigo1a>
\end{algorithmic}
\end{algorithm}

\section{Explicación del Algoritmo}

\subsection{Enfoque de Fuerza Bruta}
%<*exp1>
El algoritmo de fuerza bruta para programación de trabajos funciona de la siguiente manera:

\begin{itemize}
    \item \textbf{Generación de permutaciones:} Se generan todas las posibles permutaciones del conjunto de trabajos
    \item \textbf{Evaluación de cada permutación:} Para cada permutación, se simula la ejecución de trabajos en orden
    \item \textbf{Verificación de deadlines:} Solo se incluyen trabajos que pueden completarse antes de su deadline
    \item \textbf{Optimización:} Se mantiene la mejor programación encontrada hasta el momento
\end{itemize}

La complejidad del algoritmo viene del hecho de que se prueban todas las $n!$ permutaciones posibles de los trabajos.
%</exp1>

\subsection{Restricciones del Problema}
%<*exp2>
Para cada permutación de trabajos, se aplican las siguientes restricciones:

\begin{itemize}
    \item \textbf{Deadline:} Un trabajo solo puede ser incluido si $tiempo\_actual < deadline$
    \item \textbf{Tiempo unitario:} Cada trabajo toma exactamente 1 unidad de tiempo
    \item \textbf{Secuencialidad:} Los trabajos se ejecutan en el orden de la permutación
    \item \textbf{Objetivo:} Maximizar la suma de ganancias de los trabajos incluidos
\end{itemize}

Matemáticamente, para una permutación $P = (j_1, j_2, ..., j_n)$:
$$\max \sum_{i=1}^{k} profit(j_i)$$
donde $k$ es el número de trabajos que pueden completarse antes de sus deadlines.
%</exp2>

\subsection{Complejidad}
%<*exp3>
\begin{itemize}
    \item \textbf{Tiempo:} $O(n! \cdot n)$
    \begin{itemize}
        \item $O(n!)$ para generar todas las permutaciones
        \item $O(n)$ para evaluar cada permutación
    \end{itemize}
    \item \textbf{Espacio:} $O(n)$ para almacenar la mejor programación
\end{itemize}

Esta complejidad factorial hace que el algoritmo sea impráctico para problemas grandes, pero garantiza encontrar la solución óptima.
%</exp3>

\section{Resolución Paso a Paso}

\subsection{Ejemplo: Trabajos = [("a",2,100), ("b",1,19), ("c",2,27), ("d",1,25), ("e",3,15)]}

\textbf{Trabajos de entrada:}
\begin{center}
\begin{tabular}{|c|c|c|}
\hline
\textbf{ID} & \textbf{Deadline} & \textbf{Ganancia} \\
\hline
a & 2 & 100 \\
b & 1 & 19 \\
c & 2 & 27 \\
d & 1 & 25 \\
e & 3 & 15 \\
\hline
\end{tabular}
\end{center}

\textbf{Paso 1:} Identificar parámetros del problema
\begin{itemize}
    \item Número de trabajos: $n = 5$
    \item Total de permutaciones posibles: $5! = 120$
    \item Objetivo: Encontrar la permutación que maximice la ganancia
\end{itemize}

\textbf{Paso 2:} Ejemplos de permutaciones y sus evaluaciones

\textbf{Permutación 1:} (a, b, c, d, e)
\begin{itemize}
    \item Tiempo 0: Trabajo a (deadline=2) → Incluir, ganancia=100, tiempo=1
    \item Tiempo 1: Trabajo b (deadline=1) → $1 \not< 1$, NO incluir
    \item Tiempo 1: Trabajo c (deadline=2) → $1 < 2$, Incluir, ganancia=127, tiempo=2
    \item Tiempo 2: Trabajo d (deadline=1) → $2 \not< 1$, NO incluir
    \item Tiempo 2: Trabajo e (deadline=3) → $2 < 3$, Incluir, ganancia=142, tiempo=3
    \item \textbf{Resultado:} Ganancia = 142, Programación = [a, c, e]
\end{itemize}

\textbf{Permutación 2:} (b, a, c, d, e)
\begin{itemize}
    \item Tiempo 0: Trabajo b (deadline=1) → $0 < 1$, Incluir, ganancia=19, tiempo=1
    \item Tiempo 1: Trabajo a (deadline=2) → $1 < 2$, Incluir, ganancia=119, tiempo=2
    \item Tiempo 2: Trabajo c (deadline=2) → $2 \not< 2$, NO incluir
    \item Tiempo 2: Trabajo d (deadline=1) → $2 \not< 1$, NO incluir
    \item Tiempo 2: Trabajo e (deadline=3) → $2 < 3$, Incluir, ganancia=134, tiempo=3
    \item \textbf{Resultado:} Ganancia = 134, Programación = [b, a, e]
\end{itemize}

\textbf{Permutación 3:} (d, a, c, b, e)
\begin{itemize}
    \item Tiempo 0: Trabajo d (deadline=1) → $0 < 1$, Incluir, ganancia=25, tiempo=1
    \item Tiempo 1: Trabajo a (deadline=2) → $1 < 2$, Incluir, ganancia=125, tiempo=2
    \item Tiempo 2: Trabajo c (deadline=2) → $2 \not< 2$, NO incluir
    \item Tiempo 2: Trabajo b (deadline=1) → $2 \not< 1$, NO incluir
    \item Tiempo 2: Trabajo e (deadline=3) → $2 < 3$, Incluir, ganancia=140, tiempo=3
    \item \textbf{Resultado:} Ganancia = 140, Programación = [d, a, e]
\end{itemize}

\textbf{Paso 3:} Continuar evaluando permutaciones hasta encontrar la óptima

Después de evaluar múltiples permutaciones, se encuentra:

\textbf{Permutación óptima:} (a, c, d, b, e)
\begin{itemize}
    \item Tiempo 0: Trabajo a (deadline=2) → $0 < 2$, Incluir, ganancia=100, tiempo=1
    \item Tiempo 1: Trabajo c (deadline=2) → $1 < 2$, Incluir, ganancia=127, tiempo=2
    \item Tiempo 2: Trabajo d (deadline=1) → $2 \not< 1$, NO incluir
    \item Tiempo 2: Trabajo b (deadline=1) → $2 \not< 1$, NO incluir
    \item Tiempo 2: Trabajo e (deadline=3) → $2 < 3$, Incluir, ganancia=142, tiempo=3
    \item \textbf{Resultado:} Ganancia = 142, Programación = [a, c, e]
\end{itemize}

\textbf{Paso 4:} Verificar si existe una mejor solución

Continuando la búsqueda exhaustiva:

\textbf{Permutación mejorada:} (a, c, e, b, d)
\begin{itemize}
    \item Tiempo 0: Trabajo a (deadline=2) → $0 < 2$, Incluir, ganancia=100, tiempo=1
    \item Tiempo 1: Trabajo c (deadline=2) → $1 < 2$, Incluir, ganancia=127, tiempo=2
    \item Tiempo 2: Trabajo e (deadline=3) → $2 < 3$, Incluir, ganancia=142, tiempo=3
    \item Tiempo 3: Trabajo b (deadline=1) → $3 \not< 1$, NO incluir
    \item Tiempo 3: Trabajo d (deadline=1) → $3 \not< 1$, NO incluir
    \item \textbf{Resultado:} Ganancia = 142, Programación = [a, c, e]
\end{itemize}

\textbf{Resultado Final:} La ganancia máxima es 142, obtenida con la programación [a, c, e].

\subsection{Visualización de la Solución Óptima}
\begin{center}
\begin{tabular}{|c|c|c|c|}
\hline
\textbf{Tiempo} & \textbf{Trabajo} & \textbf{Deadline} & \textbf{Ganancia} \\
\hline
0 & a & 2 & 100 \\
1 & c & 2 & 27 \\
2 & e & 3 & 15 \\
\hline
\textbf{Total} & & & \textbf{142} \\
\hline
\end{tabular}
\end{center}

\textbf{Justificación:}
\begin{itemize}
    \item El trabajo 'a' se ejecuta en tiempo 0 (antes de deadline 2)
    \item El trabajo 'c' se ejecuta en tiempo 1 (antes de deadline 2)
    \item El trabajo 'e' se ejecuta en tiempo 2 (antes de deadline 3)
    \item Los trabajos 'b' y 'd' no pueden incluirse porque sus deadlines (1) ya han pasado
\end{itemize}

\section{Análisis de Complejidad}

\subsection{Comparación con Algoritmos Greedy}
%<*exp4>
\begin{itemize}
    \item \textbf{Fuerza Bruta:} $O(n! \cdot n)$ - Garantiza solución óptima
    \item \textbf{Algoritmo Greedy por Ganancia:} $O(n \log n)$ - Puede no ser óptimo
    \item \textbf{Algoritmo Greedy por Deadline:} $O(n \log n)$ - Puede no ser óptimo
\end{itemize}

\textbf{Ventajas del enfoque de fuerza bruta:}
\begin{itemize}
    \item Garantiza encontrar la solución óptima
    \item Útil para verificar la corrección de algoritmos heurísticos
    \item Apropiado para problemas pequeños
\end{itemize}

\textbf{Desventajas:}
\begin{itemize}
    \item Complejidad factorial hace que sea impráctico para $n > 10$
    \item No aprovecha la estructura del problema
    \item Consume mucho tiempo computacional
\end{itemize}
%</exp4>

\section{Conclusiones}

El algoritmo de fuerza bruta para programación de trabajos garantiza encontrar la solución óptima pero tiene una complejidad factorial que lo hace impráctico para problemas grandes. Es útil para:

\begin{itemize}
    \item Verificar la corrección de algoritmos más eficientes
    \item Resolver instancias pequeñas del problema
    \item Estudios teóricos sobre la optimalidad de soluciones
\end{itemize}

Para aplicaciones prácticas, se recomienda usar algoritmos greedy o de programación dinámica que, aunque pueden no garantizar optimalidad, ofrecen soluciones razonables en tiempo polinomial.

\end{document}
