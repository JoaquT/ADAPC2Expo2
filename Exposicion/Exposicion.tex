\documentclass[aspectratio=169]{beamer}
\usetheme{Madrid}

% ====== Language & encoding ======
\usepackage[spanish,es-nodecimaldot]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{catchfilebetweentags}

% ====== Useful packages for later editing ======
\usepackage{graphicx}
\usepackage{booktabs}
\usepackage{amsmath, amssymb}
\usepackage{array}
\usepackage{listings}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{xcolor}
\usepackage{float}
\usepackage{tikz}
\usepackage{forest}

% Código
\usepackage{listingsutf8}
\lstset{
    inputencoding=utf8,
    extendedchars=true,
    columns=fullflexible,
    breaklines=true,
    showstringspaces=false,
}

% Paleta de colores
\definecolor{codebg}{RGB}{0,0,0}
\definecolor{c-linenum}{RGB}{120,120,120}
\definecolor{c-key}{RGB}{97,175,239}
\definecolor{c-str}{RGB}{152,195,121}
\definecolor{c-com}{RGB}{92,99,112}
\definecolor{c-id}{RGB}{224,108,117}
\definecolor{c-builtin}{RGB}{198,120,221}
\definecolor{c-num}{RGB}{209,154,102}

% Mapeo de tildes/ñ/¿/¡ para listings
\lstset{literate=
 {á}{{\'a}}1 {é}{{\'e}}1 {í}{{\'\i}}1 {ó}{{\'o}}1 {ú}{{\'u}}1
 {Á}{{\'A}}1 {É}{{\'E}}1 {Í}{{\'I}}1 {Ó}{{\'O}}1 {Ú}{{\'U}}1
 {ñ}{{\~n}}1 {Ñ}{{\~N}}1 {ü}{{\"u}}1 {Ü}{{\"U}}1
 {¿}{{\textquestiondown}}1 {¡}{{\textexclamdown}}1
}

% Configuración de algoritmos
\floatname{algorithm}{Algoritmo}
\renewcommand{\algorithmicrequire}{\textbf{Entrada:}}
\renewcommand{\algorithmicensure}{\textbf{Salida:}}
\renewcommand{\thealgorithm}{}

% Comandos personalizados para algoritmos
\makeatletter
\newcommand{\REQUIRE}{\State[\algorithmicrequire]}
\newcommand{\ENSURE}{\State[\algorithmicensure]}
\makeatother

% ====== Title data ======
\title[Análisis y Diseño de Algoritmos]{Exposición: Problemas de Análisis y Diseño de Algoritmos}
\subtitle{Brute Force vs Greedy}
\author[Delgado, G. \and Torres, J. \and Quintanilla, D.]{Delgado Romero, Gustavo \\ Torres Reategui, Joaquin \\ Quintanilla Quispe, Dylan}
\institute[UNI]{Universidad Nacional de Ingeniería \\ CC371 - Análisis y Diseño de Algoritmos}
\date{\today}

\begin{document}

% ====== Title ======
\begin{frame}
\titlepage
\end{frame}

% ====== Agenda ======
\begin{frame}{Tabla de Contenidos}
\tableofcontents[hideallsubsections]
\end{frame}

% ====== Resumen de Problemas ======
\begin{frame}{Resumen de Problemas}
\begin{block}{Problemas a Desarrollar}
\begin{enumerate}
\item \textbf{Activity Selection Problem} - Selección de actividades
\item \textbf{Graph Coloring} - Coloreo de grafos
\item \textbf{Job Scheduling with Deadlines} - Programación de trabajos
\item \textbf{Huffman Codes} - Códigos de Huffman
\end{enumerate}
\end{block}

\begin{block}{Enfoques Comparados}
\begin{itemize}
\item \textbf{Fuerza Bruta}: Solución óptima garantizada, complejidad exponencial
\item \textbf{Greedy}: Solución eficiente, no siempre óptima, complejidad polinomial
\end{itemize}
\end{block}
\end{frame}

% =======================================================
% PROBLEMA 1: Activity Selection Problem
% =======================================================
\section{Problema 1: Activity Selection Problem}

\begin{frame}{Tabla de Contenidos}
\tableofcontents[currentsection,hideothersubsections]
\end{frame}

\subsection{Enunciado}
\begin{frame}{Activity Selection Problem - Enunciado}
\begin{block}{Descripción del Problema}
Seleccionar el máximo número de actividades mutuamente compatibles de un conjunto dado. Cada actividad tiene:
\begin{itemize}
\item Tiempo de inicio y finalización
\item Compatibilidad: No deben solaparse en el tiempo
\item Objetivo: Maximizar el número de actividades seleccionadas
\end{itemize}
\end{block}

\begin{exampleblock}{Ejemplo}
Actividades: [(1,2), (3,4), (0,6), (5,7), (8,9), (5,9)]\\
Solución óptima: 4 actividades
\end{exampleblock}
\end{frame}

\subsection{Enfoque de Fuerza Bruta}
\begin{frame}{Activity Selection - Fuerza Bruta}
\begin{block}{Estrategia}
\begin{itemize}
\item Generar todos los subconjuntos posibles de actividades
\item Verificar compatibilidad para cada subconjunto
\item Seleccionar el subconjunto válido de mayor tamaño
\end{itemize}
\end{block}

\begin{alertblock}{Complejidad}
$O(2^n \cdot n^2)$ - Exponencial
\end{alertblock}
\end{frame}

\subsubsection{Pseudocódigo (Brute Force)}
\begin{frame}[fragile]{Activity Selection - Pseudocódigo Fuerza Bruta}
\scriptsize
\begin{algorithmic}[1]
\REQUIRE Un arreglo $activities$ de $n$ elementos donde cada elemento es una tupla $(start, end)$
\ENSURE El subconjunto de máximo tamaño de actividades mutuamente compatibles
\State $n \leftarrow$ longitud de $activities$ \Comment{Cantidad de actividades}
\State $best \leftarrow$ lista vacía \Comment{Mejor subconjunto encontrado}
\Comment{Probar todos los subconjuntos posibles}
\For{$r = 1$ to $n$}
    \For{cada $subset$ en $combinations(activities, r)$}
        \If{$is\_valid(subset)$ $\land$ $|subset| > |best|$} \Comment{Compatibilidad y tamaño}
            \State $best \leftarrow subset$ \Comment{Actualizar mejor solución}
        \EndIf
    \EndFor
\EndFor
\Return $best$
\end{algorithmic}
\normalsize
\end{frame}

\subsubsection{Ejemplo explicativo (Brute Force)}
\begin{frame}[allowframebreaks]{Activity Selection - Ejemplo Fuerza Bruta}
\begin{exampleblock}{Actividades: [(1,3), (2,5), (4,6)]}
\textbf{Paso 1:} Identificar actividades A=(1,3), B=(2,5), C=(4,6)
\\
\textbf{Paso 2:} Subconjuntos de tamaño 1
\begin{itemize}
    \item \{A\}, \{B\}, \{C\}: Todos válidos
\end{itemize}
\textbf{Mejor hasta ahora:} tamaño 1
\\
\textbf{Paso 3:} Subconjuntos de tamaño 2
\begin{itemize}
    \item \{A,B\}: 3 > 2 $\rightarrow$ Se solapan $\rightarrow$ Inválido
    \item \{A,C\}: 3 $\le$ 4 $\rightarrow$ No se solapan $\rightarrow$ Válido
    \item \{B,C\}: 5 > 4 $\rightarrow$ Se solapan $\rightarrow$ Inválido
\end{itemize}
\textbf{Mejor hasta ahora:} \{A,C\}
\\
\textbf{Paso 4:} Subconjunto de tamaño 3
\begin{itemize}
    \item \{A,B,C\}: Hay solapamientos $\rightarrow$ Inválido
\end{itemize}
\end{exampleblock}

\begin{block}{Solución óptima}
\{A,C\} con 2 actividades
\end{block}
\end{frame}

\subsection{Enfoque Greedy}
\begin{frame}{Activity Selection - Enfoque Greedy}
\begin{block}{Estrategia Óptima}
\begin{itemize}
\item Ordenar actividades por tiempo de finalización
\item Seleccionar siempre la siguiente actividad que termina primero y no se solape
\end{itemize}
\end{block}

\begin{alertblock}{Complejidad}
$O(n \log n)$ - Polinomial (óptimo)
\end{alertblock}
\end{frame}

\subsubsection{Pseudocódigo (Greedy)}
\begin{frame}[fragile]{Activity Selection - Pseudocódigo Greedy}
\scriptsize
\begin{algorithmic}[1]
\REQUIRE Arreglos $start$ y $finish$ de $n$ elementos con tiempos de inicio y fin
\ENSURE El número máximo de actividades mutuamente compatibles
\State $activities \leftarrow$ lista de tuplas $(start[i], finish[i])$ para $i=0..n-1$ \Comment{Crear pares inicio-fin}
\State Ordenar $activities$ por tiempo de finalización ascendente \Comment{Clave para optimalidad}
\State $count \leftarrow 1$ \Comment{Al menos una actividad puede realizarse}
\State $j \leftarrow 0$ \Comment{Índice de la última actividad seleccionada}
\For{$i = 1$ to $n-1$}
    \If{$activities[i].start > activities[j].finish$} \Comment{Verifica no solapamiento}
        \State $count \leftarrow count + 1$ \Comment{Selecciona actividad}
        \State $j \leftarrow i$ \Comment{Actualiza última seleccionada}
    \EndIf
\EndFor
\Return $count$
\end{algorithmic}
\normalsize
\end{frame}

\subsubsection{Ejemplo explicativo (Greedy)}
\begin{frame}[allowframebreaks]{Activity Selection - Ejemplo Greedy}
\begin{exampleblock}{Actividades = [(1, 2), (3, 4), (0, 6), (5, 7), (8, 9), (5, 9)]}
\textbf{Paso 1:} Crear tuplas y ordenar por fin: (1,2), (3,4), (0,6), (5,7), (8,9), (5,9)
\end{exampleblock}

\begin{block}{Iteraciones}
\begin{itemize}
    \item i=1: (3,4). ¿3 > 2? Sí $\rightarrow$ Seleccionar, count=2, j=1
    \item i=2: (0,6). ¿0 > 4? No $\rightarrow$ Omitir
    \item i=3: (5,7). ¿5 > 4? Sí $\rightarrow$ Seleccionar, count=3, j=3
    \item i=4: (8,9). ¿8 > 7? Sí $\rightarrow$ Seleccionar, count=4, j=4
    \item i=5: (5,9). ¿5 > 9? No $\rightarrow$ Omitir
\end{itemize}
\end{block}

\begin{block}{Resultado Final}
4 actividades: (1,2), (3,4), (5,7), (8,9)
\end{block}
\end{frame}

\subsection{Análisis comparativo de complejidad}
\begin{frame}{Activity Selection - Análisis Comparativo}
\begin{table}
\centering
\begin{tabular}{lcc}
\toprule
\textbf{Enfoque} & \textbf{Complejidad} & \textbf{Optimalidad} \\
\midrule
Fuerza Bruta & $O(2^n \cdot n^2)$ & \checkmark \\
Greedy & $O(n \log n)$ & \checkmark \\
\bottomrule
\end{tabular}
\end{table}

\begin{block}{Conclusión}
\begin{itemize}
\item Greedy es óptimo y eficiente para este problema
\item Fuerza bruta solo práctico para instancias pequeñas ($n < 20$)
\item El ordenamiento por tiempo de finalización garantiza optimalidad
\end{itemize}
\end{block}
\end{frame}

% =======================================================
% PROBLEMA 2: Graph Coloring
% =======================================================
\section{Problema 2: Graph Coloring}

\begin{frame}{Tabla de Contenidos}
\tableofcontents[currentsection,hideothersubsections]
\end{frame}

\subsection{Enunciado}
\begin{frame}{Graph Coloring - Enunciado}
\begin{block}{Descripción del Problema}
Asignar colores a vértices de un grafo tal que:
\begin{itemize}
\item Vértices adyacentes tengan colores diferentes
\item Minimizar el número de colores usado (número cromático)
\item Problema NP-completo en general
\end{itemize}
\end{block}

\begin{exampleblock}{Aplicaciones}
\begin{itemize}
\item Scheduling de procesos
\item Asignación de registros
\item Sudoku
\end{itemize}
\end{exampleblock}
\end{frame}

\subsection{Enfoque de Fuerza Bruta}
\begin{frame}{Graph Coloring - Fuerza Bruta}
\begin{block}{Estrategia}
\begin{itemize}
\item Probar todas las asignaciones de $k$ colores a $n$ vértices
\item Verificar validez para cada asignación
\item Encontrar el mínimo $k$ que permita coloreo válido
\end{itemize}
\end{block}

\begin{alertblock}{Complejidad}
$O(k^n \cdot n \cdot m)$ - Exponencial
\end{alertblock}
\end{frame}

\subsubsection{Pseudocódigo (Brute Force)}
\begin{frame}[fragile]{Graph Coloring - Pseudocódigo Fuerza Bruta}
\scriptsize
\begin{algorithmic}[1]
\REQUIRE Grafo $G$ (lista de adyacencia), número máximo de colores $k$
\ENSURE Asignación válida de colores o null
\For{cada $assignment$ en $product(range(k), repeat=n)$} \Comment{Todas las asignaciones de $k$ colores}
    \If{$is\_valid(G, assignment)$} \Comment{Verifica restricción de coloreo}
        \Return $assignment$
    \EndIf
\EndFor
\Return \textbf{null}
\end{algorithmic}

\begin{algorithmic}[1]
\Function{is\_valid}{$G$, $colors$}
\For{$u = 0$ to $|G|-1$} \Comment{Recorrer todos los vértices}
    \For{cada $v$ en $G[u]$} \Comment{Revisar vecinos}
        \If{$colors[u] = colors[v]$}
            \Return false \Comment{Vértices adyacentes con mismo color}
        \EndIf
    \EndFor
\EndFor
\Return true
\EndFunction
\end{algorithmic}
\normalsize
\end{frame}

\subsubsection{Ejemplo explicativo (Brute Force)}
\begin{frame}{Graph Coloring - Ejemplo Fuerza Bruta}
\begin{exampleblock}{Grafo con 3 vértices: Triángulo}
\begin{itemize}
\item \textbf{k=2}: Probar $2^3=8$ asignaciones, ninguna válida
\item \textbf{k=3}: Probar $3^3=27$ asignaciones
\item Encontrar solución: [0,1,2] - 3 colores
\end{itemize}
\end{exampleblock}

\begin{block}{Limitaciones}
\begin{itemize}
\item 10 vértices con 3 colores: $3^{10} = 59,049$ pruebas
\item 20 vértices: $3^{20} > 3.4$ billones de pruebas
\end{itemize}
\end{block}
\end{frame}

\subsection{Enfoque Greedy}
\begin{frame}{Graph Coloring - Enfoque Greedy}
\begin{block}{Estrategia}
\begin{itemize}
\item Procesar vértices en orden fijo
\item Asignar el menor color disponible no usado por vecinos
\item No garantiza número cromático mínimo
\end{itemize}
\end{block}

\begin{alertblock}{Complejidad}
$O(V^2 + E)$ - Polinomial
\end{alertblock}
\end{frame}

\subsubsection{Pseudocódigo (Greedy)}
\begin{frame}[fragile]{Graph Coloring - Pseudocódigo Greedy}
\scriptsize
\begin{algorithmic}[1]
\REQUIRE Grafo $G$ (lista de adyacencia) con $V$ vértices
\ENSURE Asignación válida de colores
\State $result \leftarrow$ arreglo de tamaño $V$ inicializado en $-1$ \Comment{Colores por vértice}
\State $result[0] \leftarrow 0$ \Comment{Color al primer vértice}
\State $available \leftarrow$ arreglo booleano de tamaño $V$ en false \Comment{Colores ocupados por vecinos}
\For{$u = 1$ to $V-1$}
    \Comment{Marcar colores de vecinos como no disponibles}
    \For{$i=0$ to $|adj[u]|-1$}
        \If{$result[adj[u][i]] \neq -1$}
            \State $available[result[adj[u][i]]] \leftarrow$ true
        \EndIf
    \EndFor
    \Comment{Encontrar el primer color disponible}
    \State $cr \leftarrow 0$
    \While{$cr < V$}
        \If{$available[cr] = false$}
            \State \textbf{break}
        \EndIf
        \State $cr \leftarrow cr + 1$
    \EndWhile
    \State $result[u] \leftarrow cr$ \Comment{Asignar color encontrado}
    \Comment{Resetear disponibilidad para el siguiente vértice}
    \For{$i = 0$ to $|adj[u]|-1$}
        \If{$result[adj[u][i]] \neq -1$}
            \State $available[result[adj[u][i]]] \leftarrow$ false
        \EndIf
    \EndFor
\EndFor
\Return $result$
\end{algorithmic}
\normalsize
\end{frame}

\subsubsection{Ejemplo explicativo (Greedy)}
\begin{frame}{Graph Coloring - Ejemplo Greedy}
\begin{columns}
\begin{column}{0.5\textwidth}
\begin{exampleblock}{Grafo de 5 vértices}
\begin{itemize}
\item V0: Color 0
\item V1: Color 1 (vecino de V0)
\item V2: Color 2 (vecino de V0,1)
\item V3: Color 0 (vecino de V1,2)
\item V4: Color 1 (vecino de V3)
\end{itemize}
\end{exampleblock}
\end{column}
\begin{column}{0.5\textwidth}
\begin{tikzpicture}[node distance=1.5cm]
\node[circle,draw,fill=red!30] (0) at (0,0) {0};
\node[circle,draw,fill=blue!30] (1) at (2,0) {1};
\node[circle,draw,fill=green!30] (2) at (1,1.5) {2};
\node[circle,draw,fill=red!30] (3) at (3,1.5) {3};
\node[circle,draw,fill=blue!30] (4) at (4,0) {4};
\draw (0)--(1)--(2)--(0)--(2)--(3)--(1)--(3)--(4);
\end{tikzpicture}
\end{column}
\end{columns}

\begin{block}{Resultado}
3 colores usados (óptimo para este grafo)
\end{block}
\end{frame}

\subsection{Análisis comparativo de complejidad}
\begin{frame}{Graph Coloring - Análisis Comparativo}
\begin{table}
\centering
\begin{tabular}{lcc}
\toprule
\textbf{Enfoque} & \textbf{Complejidad} & \textbf{Optimalidad} \\
\midrule
Fuerza Bruta & $O(k^n \cdot n \cdot m)$ & \checkmark \\
Greedy & $O(V^2 + E)$ & $\times$ \\
\bottomrule
\end{tabular}
\end{table}

\begin{block}{Conclusión}
\begin{itemize}
\item Fuerza bruta garantiza optimalidad pero es impráctica
\item Greedy es eficiente pero puede usar más colores de los necesarios
\item En la práctica: Greedy para grafos grandes, heurísticas avanzadas para mejor aproximación
\end{itemize}
\end{block}
\end{frame}

% =======================================================
% PROBLEMA 3: Job Scheduling with Deadlines
% =======================================================
\section{Problema 3: Job Scheduling with Deadlines}

\begin{frame}{Tabla de Contenidos}
\tableofcontents[currentsection,hideothersubsections]
\end{frame}

\subsection{Enunciado}
\begin{frame}{Job Scheduling - Enunciado}
\begin{block}{Descripción del Problema}
Programar trabajos con:
\begin{itemize}
\item Deadline: Tiempo límite para completar
\item Profit: Ganancia por completar a tiempo
\item Cada trabajo toma 1 unidad de tiempo
\item Objetivo: Maximizar ganancia total
\end{itemize}
\end{block}

\begin{exampleblock}{Aplicaciones}
\begin{itemize}
\item Scheduling de procesos en CPU
\item Planificación de producción
\item Asignación de recursos limitados
\end{itemize}
\end{exampleblock}
\end{frame}

\subsection{Enfoque de Fuerza Bruta}
\begin{frame}{Job Scheduling - Fuerza Bruta}
\begin{block}{Estrategia}
\begin{itemize}
\item Generar todas las permutaciones de trabajos
\item Para cada permutación, programar trabajos en orden
\item Solo incluir trabajos que cumplan deadline
\item Seleccionar permutación con máxima ganancia
\end{itemize}
\end{block}

\begin{alertblock}{Complejidad}
$O(n! \cdot n)$ - Factorial
\end{alertblock}
\end{frame}

\subsubsection{Pseudocódigo (Brute Force)}
\begin{frame}[fragile]{Job Scheduling - Pseudocódigo Fuerza Bruta}
\scriptsize
\begin{algorithmic}[1]
\REQUIRE Una lista $jobs$ de $n$ elementos donde cada elemento es $(id, deadline, profit)$
\ENSURE La mejor programación y la ganancia máxima
\State $max\_profit \leftarrow 0$
\State $best\_schedule \leftarrow$ lista vacía
\Comment{Probar todas las permutaciones posibles}
\For{cada $perm$ en $permutations(jobs)$}
    \State $time \leftarrow 0$ \Comment{Tiempo actual}
    \State $profit \leftarrow 0$ \Comment{Ganancia acumulada}
    \State $schedule \leftarrow$ lista vacía \Comment{Programación actual}
    \For{cada $job$ en $perm$}
        \If{$time < job.deadline$} \Comment{Verifica deadline}
            \State $schedule.append(job)$
            \State $profit \leftarrow profit + job.profit$
            \State $time \leftarrow time + 1$
        \EndIf
    \EndFor
    \If{$profit > max\_profit$}
        \State $max\_profit \leftarrow profit$
        \State $best\_schedule \leftarrow schedule$
    \EndIf
\EndFor
\Return $best\_schedule, max\_profit$
\end{algorithmic}
\normalsize
\end{frame}

\subsubsection{Ejemplo explicativo (Brute Force)}
\begin{frame}{Job Scheduling - Ejemplo Fuerza Bruta}
\begin{exampleblock}{Trabajos: [(a,2,100), (b,1,19), (c,2,27), (d,1,25), (e,3,15)]}
\begin{itemize}
\item \textbf{Permutación 1}: [a,b,c,d,e] $\rightarrow$ Ganancia: 142
\item \textbf{Permutación 2}: [b,a,c,d,e] $\rightarrow$ Ganancia: 134
\item \textbf{Permutación 3}: [d,a,c,b,e] $\rightarrow$ Ganancia: 140
\item \textbf{Mejor}: [a,c,e] con ganancia 142
\end{itemize}
\end{exampleblock}

\begin{alertblock}{Limitaciones}
5 trabajos = 120 permutaciones, 10 trabajos = 3.6 millones
\end{alertblock}
\end{frame}

\subsection{Enfoque Greedy}
\begin{frame}{Job Scheduling - Enfoque Greedy}
\begin{block}{Estrategia}
\begin{itemize}
\item Ordenar trabajos por profit descendente
\item Para cada trabajo, asignar al slot más tardío disponible dentro de su deadline
\end{itemize}
\end{block}

\begin{alertblock}{Complejidad}
$O(n \log n + n \cdot d)$ - Polinomial
\end{alertblock}
\end{frame}

\subsubsection{Pseudocódigo (Greedy)}
\begin{frame}[fragile]{Job Scheduling - Pseudocódigo Greedy}
\scriptsize
\begin{algorithmic}[1]
\REQUIRE Lista $jobs$ donde cada trabajo tiene $(id, deadline, profit)$
\ENSURE Lista de trabajos seleccionados y ganancia total
\State Ordenar $jobs$ por ganancia en orden descendente \Comment{Prioriza ganancias altas}
\State $max\_deadline \leftarrow \max\{job.deadline \;\forall job\in jobs\}$
\State $slots \leftarrow$ arreglo de tamaño $max\_deadline + 1$ inicializado en $-1$ \Comment{Slots de tiempo}
\State $total\_profit \leftarrow 0$, $scheduled\_jobs \leftarrow$ lista vacía
\For{cada $job$ en $jobs$}
    \For{$t \gets job.deadline;\ t \geq 1;\ t \gets t-1$} \Comment{Buscar slot más tardío disponible}
        \If{$slots[t] = -1$}
            \State $slots[t] \leftarrow job.id$
            \State $total\_profit \leftarrow total\_profit + job.profit$
            \State $scheduled\_jobs.append(job.id)$
            \State \textbf{break}
        \EndIf
    \EndFor
\EndFor
\Return $scheduled\_jobs, total\_profit$
\end{algorithmic}
\normalsize
\end{frame}

\subsubsection{Ejemplo explicativo (Greedy)}
\begin{frame}[allowframebreaks]{Job Scheduling - Ejemplo Greedy}
\begin{exampleblock}{Trabajos = [A(2,100), B(1,19), C(2,27), D(1,25), E(3,15)]}
\textbf{Orden por ganancia:} A(100), C(27), D(25), B(19), E(15)
\end{exampleblock}

\begin{block}{Asignación}
\begin{itemize}
    \item A (d=2): buscar t=2..1 $\rightarrow$ t=2 libre $\rightarrow$ slots[2]=A, total=100
    \item C (d=2): t=2 ocupado, t=1 libre $\rightarrow$ slots[1]=C, total=127
    \item D (d=1): t=1 ocupado $\rightarrow$ no asignar
    \item B (d=1): t=1 ocupado $\rightarrow$ no asignar
    \item E (d=3): t=3 libre $\rightarrow$ slots[3]=E, total=142
\end{itemize}
\end{block}

\begin{block}{Resultado Final}
Programación: [C, A, E] con ganancia total 142
\end{block}
\end{frame}

\subsection{Análisis comparativo de complejidad}
\begin{frame}{Job Scheduling - Análisis Comparativo}
\begin{table}
\centering
\begin{tabular}{lcc}
\toprule
\textbf{Enfoque} & \textbf{Complejidad} & \textbf{Optimalidad} \\
\midrule
Fuerza Bruta & $O(n! \cdot n)$ & \checkmark \\
Greedy & $O(n \log n + n \cdot d)$ & $\times$ \\
\bottomrule
\end{tabular}
\end{table}

\begin{block}{Conclusión}
\begin{itemize}
\item Greedy no siempre es óptimo pero es muy eficiente
\item En la práctica funciona bien para la mayoría de casos
\item Fuerza bruta solo para instancias muy pequeñas ($n < 10$)
\end{itemize}
\end{block}
\end{frame}

% =======================================================
% PROBLEMA 4: Huffman Codes
% =======================================================
\section{Problema 4: Huffman Codes}

\begin{frame}{Tabla de Contenidos}
\tableofcontents[currentsection,hideothersubsections]
\end{frame}

\subsection{Enunciado}
\begin{frame}{Huffman Codes - Enunciado}
\begin{block}{Descripción del Problema}
Encontrar código de prefijo óptimo para compresión de datos:
\begin{itemize}
\item Símbolos con frecuencias dadas
\item Código de longitud variable
\item Objetivo: Minimizar longitud promedio
\item $\text{Costo} = \sum f_i \cdot l_i$
\end{itemize}
\end{block}

\begin{exampleblock}{Aplicaciones}
\begin{itemize}
\item Compresión de archivos (ZIP, JPEG, MP3)
\item Transmisión eficiente de datos
\end{itemize}
\end{exampleblock}
\end{frame}

\subsection{Enfoque de Fuerza Bruta}
\begin{frame}{Huffman Codes - Fuerza Bruta}
\begin{block}{Estrategia}
\begin{itemize}
\item Generar todos los árboles binarios completos con n hojas
\item Para cada árbol, calcular longitudes de código
\item Probar todas las asignaciones de símbolos a hojas
\item Seleccionar asignación con mínimo costo
\end{itemize}
\end{block}

\begin{alertblock}{Complejidad}
$O(C_{n-1} \cdot n! \cdot n)$ - Super-exponencial
\end{alertblock}
\end{frame}

\subsubsection{Pseudocódigo (Brute Force)}
\begin{frame}[fragile]{Huffman Codes - Pseudocódigo Fuerza Bruta}
\begin{algorithmic}[1]
\REQUIRE Símbolos y frecuencias
\ENSURE Asignación óptima de códigos
\State $n \leftarrow$ número de símbolos
\State $best\_cost \leftarrow \infty$, $best\_assignment \leftarrow$ null
\For{cada $tree$ en $generate\_trees(n)$}
    \State $lengths \leftarrow code\_lengths(tree)$
    \For{cada $perm$ en $permutations(range(n))$}
        \State $cost \leftarrow \sum freqs[perm[i]] \cdot lengths[i]$
        \If{$cost < best\_cost$}
            \State $best\_cost \leftarrow cost$, $best\_assignment \leftarrow$ asignación
        \EndIf
    \EndFor
\EndFor
\Return $best\_cost, best\_assignment$
\end{algorithmic}
\end{frame}

\subsubsection{Ejemplo explicativo (Brute Force)}
\begin{frame}{Huffman Codes - Ejemplo Fuerza Bruta}
\begin{exampleblock}{4 símbolos: [A:5, B:2, C:1, D:1]}
\begin{itemize}
\item Número de árboles: $C_3 = 5$
\item Permutaciones por árbol: $4! = 24$
\item Total: $5 \times 24 = 120$ asignaciones
\item \textbf{Mejor}: A$\rightarrow$1, B$\rightarrow$2, C$\rightarrow$2, D$\rightarrow$3 (Costo=14)
\end{itemize}
\end{exampleblock}

\begin{alertblock}{Limitaciones}
6 símbolos: $C_5 = 42$ árboles $\times$ $6! = 720$ $\times$ 6 = 181,440 operaciones
\end{alertblock}
\end{frame}

\subsection{Enfoque Greedy}
\begin{frame}{Huffman Codes - Enfoque Greedy}
\begin{block}{Estrategia Óptima}
\begin{itemize}
\item Usar min-heap por frecuencias
\item Combinar siempre los dos nodos de menor frecuencia
\item Construir árbol de abajo hacia arriba
\end{itemize}
\end{block}

\begin{alertblock}{Complejidad}
$O(n \log n)$ - Polinomial (óptimo)
\end{alertblock}
\end{frame}

\subsubsection{Pseudocódigo (Greedy)}
\begin{frame}[fragile]{Huffman Codes - Pseudocódigo Greedy}
\scriptsize
\begin{algorithmic}[1]
\REQUIRE Lista de símbolos $s$ y frecuencias $freq$
\ENSURE Códigos Huffman óptimos
\State $n \leftarrow$ longitud de $s$
\State $pq \leftarrow$ cola de prioridad (min-heap) vacía \Comment{Menor frecuencia primero}
\Comment{Crear nodos hoja para cada símbolo}
\For{$i = 0$ to $n-1$}
    \State $tmp \leftarrow Node(freq[i])$
    \State $pq.push(tmp)$
\EndFor
\Comment{Construir árbol de Huffman}
\While{$|pq| \geq 2$}
    \State $l \leftarrow pq.pop()$ \Comment{Nodo con menor frecuencia}
    \State $r \leftarrow pq.pop()$ \Comment{Siguiente menor}
    \State $new \leftarrow Node(l.freq + r.freq)$
    \State $new.left \leftarrow l$, $new.right \leftarrow r$
    \State $pq.push(new)$
\EndWhile
\State $root \leftarrow pq.pop()$
\State Generar códigos con recorrido preorden desde $root$
\Return lista de códigos por símbolo
\end{algorithmic}
\normalsize
\end{frame}

\subsubsection{Ejemplo explicativo (Greedy)}
\begin{frame}{Huffman Codes - Ejemplo Greedy}
\begin{exampleblock}{Símbolos: [a:5, b:9, c:12, d:13, e:16, f:45]}
\begin{itemize}
\item Combinar a(5) + b(9) = 14
\item Combinar c(12) + d(13) = 25
\item Combinar 14 + e(16) = 30
\item Combinar 25 + 30 = 55
\item Combinar f(45) + 55 = 100
\end{itemize}
\end{exampleblock}

\begin{block}{Resultado}
Códigos óptimos: f$\rightarrow$0, c$\rightarrow$100, d$\rightarrow$101, a$\rightarrow$1100, b$\rightarrow$1101, e$\rightarrow$111
\end{block}
\end{frame}

\subsection{Análisis comparativo de complejidad}
\begin{frame}{Huffman Codes - Análisis Comparativo}
\begin{table}
\centering
\begin{tabular}{lcc}
\toprule
\textbf{Enfoque} & \textbf{Complejidad} & \textbf{Optimalidad} \\
\midrule
Fuerza Bruta & $O(C_{n-1} \cdot n! \cdot n)$ & \checkmark \\
Greedy & $O(n \log n)$ & \checkmark \\
\bottomrule
\end{tabular}
\end{table}

\begin{block}{Conclusión}
\begin{itemize}
\item Huffman greedy es óptimo y eficiente
\item Raro caso donde greedy garantiza optimalidad
\item Fuerza bruta completamente impráctica
\item Algoritmo ampliamente usado en compresión
\end{itemize}
\end{block}
\end{frame}

% =======================================================
% CONCLUSIONES Y RECOMENDACIONES
% =======================================================
\section{Conclusiones y Recomendaciones}

\begin{frame}{Tabla de Contenidos}
\tableofcontents[currentsection,hideothersubsections]
\end{frame}

\begin{frame}{Conclusiones Generales}
\begin{block}{Comparativa de Enfoques}
\begin{table}
\centering
\small
\begin{tabular}{lcccc}
\toprule
\textbf{Problema} & \textbf{BF Optimal} & \textbf{Greedy Optimal} & \textbf{BF Complejidad} & \textbf{Greedy Complejidad} \\
\midrule
Activity Selection & \checkmark & \checkmark & $O(2^n n^2)$ & $O(n \log n)$ \\
Graph Coloring & \checkmark & $\times$ & $O(k^n nm)$ & $O(V^2 + E)$ \\
Job Scheduling & \checkmark & $\times$ & $O(n! n)$ & $O(n \log n + nd)$ \\
Huffman Codes & \checkmark & \checkmark & $O(C_{n-1} n! n)$ & $O(n \log n)$ \\
\bottomrule
\end{tabular}
\end{table}
\end{block}

\begin{block}{Insights Clave}
\begin{itemize}
\item Greedy es óptimo cuando el problema exhibe \textbf{subestructura óptima}
\item La \textbf{elección greedy} debe preservar la posibilidad de solución óptima
\item Fuerza bruta es invaluable para verificar correctitud de algoritmos
\end{itemize}
\end{block}
\end{frame}

\begin{frame}{Recomendaciones Prácticas}
\begin{block}{Cuándo usar cada enfoque}
\begin{itemize}
\item \textbf{Fuerza Bruta}: 
\begin{itemize}
\item Problemas pequeños ($n \leq 20$)
\item Verificación de algoritmos
\item Casos donde se necesita optimalidad garantizada
\end{itemize}

\item \textbf{Greedy}:
\begin{itemize}
\item Problemas grandes donde optimalidad no es crítica
\item Cuando el problema exhibe subestructura óptima
\item Aplicaciones en tiempo real que requieren rapidez
\end{itemize}
\end{itemize}
\end{block}

\begin{exampleblock}{Estrategia Híbrida}
En la práctica: Empezar con greedy, usar fuerza bruta para casos pequeños o como verificación
\end{exampleblock}
\end{frame}

\begin{frame}{Preguntas y Discusión}
\begin{center}
\Huge ¿Preguntas?
\end{center}

\begin{block}{Contacto}
\begin{itemize}
\item Delgado Romero
\item Torres Reategui 
\item Quintanilla Quispe
\end{itemize}
\end{block}

\begin{center}
¡Gracias por su atención!
\end{center}
\end{frame}

\end{document}
